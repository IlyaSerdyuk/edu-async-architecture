# Черновой проект системы
## Сервисы и их задачи
### Auth
- Аутентификация
- Хранение данных пользователей

### Tasks
- Хранение и просмотр задач
- Добавление задач
- Переназначение задач, включая массовое

### Accounts
- Хранение движения по счетам пользователей
- Дашборд для исполнителей
- Дашборд для топ-менеджмента

### Billing
- Проведение выплат
- Хранение отчетов по выплатам

### Mailer
- Отправка писем о выплате

### Analytics
- Хранение данных в оптимизированном для статистики виде

У каждого сервиса свой фронтенд.

Роутинг между ними осуществляется на сетевом уровне (nginx).

Авторизация устанавливает куки (id и role), которые используют все сервисы.

Возможно, понадобится сервис для поддержки сессий.

Принцип разделения на сервисы: замыкание домена со всеми задачами над ним. В одном сервисе высокая связанность и консистентность.

## Схемы данных сервисов
У каждого сервиса своя БД.

### Auth
Users: id, email, role

### Tasks
Tasks: id, title, status, user_id

### Accounts
Transactions: id, datetime, user_id, task_id, amount, balance

### Billing
Users: id, card_number (перечисляем по номеру карты), status

### Mailer
Mails: id, email, message, status, datetime

### Analytics
Dates: id, date, profit (доход топов), losers (число ушедших в минус), task_top_id

## Взаимодействие сервисов
Сервисы взаимодействуют ассинхронно через брокер сообщений.

Дополнение информации из данных других сервисов осуществляется через REST API, что сокращает дублирование данных. Можно сократить и эту связность, но тогда придётся хранить одни и тоже данные в нескольких местах.

Принцип «А»: управление через брокер сообщение, просмотр через REST API.

### Auth
Пока придерживаемся принципа А, сервис не взаимодействует с другими сервисами.

#### REST API:
- Получить список исполнителей
- Получить имя пользователя (login) по id

### Tasks
#### Исходящие сообщения:
- Задача назначена (task_id, user_id, datetime)
- Задача закрыта (task_id, datetime)

#### REST API:
- Получить информацию задачи по её id

### Accounts
#### Исходящие сообщения:
- Выплата попугаю (user_id, amount)

#### Входящие сообщения:
- Задача назначена
- Задача закрыта

### Billing
#### Входящие сообщения:
- Выплата попугаю

#### REST API:
- Проверка статуса выплаты

### Mailer
#### Входящие сообщения:
- Выплата попугаю

### Analytics
#### Входящие сообщения:
- Задача назначена
- Задача закрыта

Сервисы знают и поддерживают актуальность только внутри себя. Им не важно что происходит за их пределами. Информация по REST API из других сервисов используется справочно. Сервисы отправляют сообщения в брокер и дальше им особо не важно что делают другие – их зона ответственности замкнута в них самих.

Например, сервис Accounts рассчитал выплаты и сказал всем – выплачиваем 10 рублей попугаю Пете. Все, ответственность Accounts на этом оканчивается. А уже сервисы Billing и Mailer слушают сообщения о выплате и делают то, что умеют лучше всего (точнее единственое что могут).

Дальше в любом случае получается связность – Accounts должен как-то показать получателю, что ему отправлены деньги и письмо. Можно было бы в Accounts при отображение повесить зацепку, типа «если кто хочет что-то ответить, то сейчас самое время», на которую отзовутся Billing и Mailer вставив свои виджеты. Но на React пока не очень представляю как такое сделать, по этому Accounts получает информацию о REST API сервисов Billing и Mailer и по нему запрашивает данные.

## Инфраструктура
Все сервисы живут в докере и оркестрируются docker compose.

БД: один контейнер с MySQL, разные базы у каждого сервиса.

Брокер сообщений: контейнер с RabbitMQ.

Веб-сервер: nginx

## Восстановленеи при сбоях
Если появились проблемы данные в безопасности. При пропаже сообщений из брокера можно почти везде легко найти отсутствующие. Вот с изменением задач – для того потребуется дополнительно вести историю изменений. Сейчас опустил историю изменения задач для упрощения. Во всех остальных случаях данных при минимальной описанной схеме достаточно.
